# Function that runs backup script and then returns to working directory.
backup () {
    cd ~
    if [[ $1 != '' ]] then
        sh backup.sh $1
    else
        sh backup.sh
        echo '\033[1;33mCommit message needed for pushing to github!!\033[0m'
    fi
    cd -
}

# Function that runs backup status script and then returns to working directory.
backupst () {
    cd ~
    sh backupst.sh
    cd -
}

# Function that runs backup diff script and then returns to working directory.
backupdiff () {
    cd ~
    sh backupdiff.sh
    cd -
}

# Make dir and then cd into it
cdir () {
    mkdir -p -- "$1" &&
    cd -P -- "$1"
}

# Initialize project and bootstrap npm & Git
initproject () {
    echo "Initializing project at $(pwd)"
    git init
    npm init -y
    code .
}

# Reload terminal settings
refresh () {
    . ~/.zshrc
}

# Extract any time of compressed file
function extract {
    echo Extracting $1 ...
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1  ;;
            *.tar.gz)    tar xzf $1  ;;
            *.bz2)       bunzip2 $1  ;;
            *.rar)       rar x $1    ;;
            *.gz)        gunzip $1   ;;
            *.tar)       tar xf $1   ;;
            *.tbz2)      tar xjf $1  ;;
            *.tgz)       tar xzf $1  ;;
            *.zip)       unzip $1   ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1  ;;
            *)        echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Kill a process on port
killport() {
    port=$(lsof -n -i4TCP:$1 | grep LISTEN | awk '{ print $2 }')
    kill -9 $port
}

# Lints only changed files in repo
#    CSS=$(git status | grep '.css' | awk '{print $NF}') && echo $CSS | sed 's/ /\\\n/g' && node ./node_modules/stylelint/bin/stylelint.js $CSS || true
#    FILES=$(git status | grep '.js$' | awk '{print $NF}') && echo $FILES | sed 's/ /\\\n/g' || true

gitlint() {
    FILES=$(git status | grep '.js$' | awk '{print $NF}' | tr '\n' ' ')
    echo $FILES
    ARR=$(IFS=', ' read -r -a array <<< echo $FILES)
    echo $ARR

}
